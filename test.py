import random
def splice(n):
	'''This funtion calculates the result of a simple equation given as a string. It does so by slicing the string where the operator is and calculating the result of the resulting two strings using recursion.''' 
	p = 0
	t = 0
	#first checking if the string has any operator or not.
	for i in n:
		if i.isdigit() == False:
			p +=1
	#if the string has no operator, then the functions just gives an integer by directly changing the type of string.
	if p == 0:
		return int(n)
	
	q = 0
	a = ""
	b = ""
	e = ""
	c = 0
	minus = 0
	divi = 0
	#the following loops slices the string at the operators. The order at which the loops are put corresponds to the order of application of operators.
	for i in range(len(n)):
		if n[i] == "+":
			e = n[i]
			a = n[:i]
			b = n[i+1:]
			q = 1
			break
	#if the string has already been sliced at "+" sign, then the following loop doesn't work and same with all other for loops that follow
	if q != 1:
		for i in range(len(n)):
			if n[i] == "-":
				e = n[i]
				a = n[:i]
				b = n[i+1:]
				c = int(n[i+1])
				q = 1
				break
		#this loop is added because of how negative sign works,we will see it's use ahead
		for i in range(len(n)):
			if n[i] == "-":
				minus += 1

	if q != 1:
		for i in range(len(n)):	
			if n[i] == "*":
				e = n[i]
				a = n[:i]
				b = n[i+1:]
				q = 1
				break

	if q != 1:
		for i in range(len(n)):	
			if n[i] == "/":
				e = n[i]
				a = n[:i]
				b = n[i+1:]
				c = int(n[i+1])
				q = 1
				break
		#same as with negative sign, this loop is added due to different behaviour of division sign, it's use will be seen ahead
		for i in range(len(n)):
			if n[i] == "/":
				divi += 1
	
	#recursion is used to get result of sliced strings as integers
	r = splice(a)
	s = splice(b)
	#the following loops performs the operations on the recursed versions of sliced strings
	if e == "+":
		t = r + s
	#negative has two cases (when there only one minus sign and when there's more than one) because of it's behaviour
	if e == "-" and minus == 1:
		t = r - s
	if e == "-" and minus > 1:
		t = r + s - (2*c)
	if e == "*":
		t = r * s
	#division has two cases (when there only one divide sign and when there's more than one) because of it's behaviour
	if e == "/" and divi == 1:
		t = r / s
	if e == "/" and divi > 1:
		t = (r*s) / (c*c)

	return t

def eqgen():
	'''This funtion is usedto generate a random expression which fits the requirements to be an answer for our game. It generates a different answer every time the game is played'''
	#the equations generated are divided into 3 cases depending on number of digits of the result

	#first case where the answer is 2 digits long
	#this case has 4 more case	
	#this loop makes random expressions until their answer is a 2-digit integer 
	t = '1001/10'
	while 10 > splice(t) or splice(t) > 100 or type(splice(t)) == float:
		a = random.randint(1,9)
		b = random.randint(1,9)
		c = random.randint(1,9)
		d = random.randint(1,9)
		operators = ['+', '-','*','/']
		#the following are 5 cases where each case is generated by filling 5 places with random integers(1-digit) and operators
		p = ("{}{}{}{}{}".format(a, random.choice(operators),b,random.choice(operators),c))
		q = ("{}{}{}{}{}".format(a,b, random.choice(operators),c,d))
		r = ("{}{}{}{}{}".format(a,b,c, random.choice(operators),d))
		s = ("{}{}{}{}{}".format(a,random.choice(operators),b,c,d))
		#then we put the 5 expressions in list and randomly pick one of them
		l =[p,q,r,s]
		t = random.choice(l)
	
	#this loop makes random expressions until their answer is a 3-digit integer
	u = '10'
	while splice(u) < 99:
		a = random.randint(1,9)
		b = random.randint(1,9)
		c = random.randint(1,9)
		#filling 4 places with 3 random integers and "*" or "+" sign because only multiplication or addition can give us 3-digit numbers 
		p = ("{}*{}{}".format(a,b,c))
		q = ("{}{}*{}".format(a,b,c))
		r = ("{}{}+{}".format(a,b,c))
		s = ("{}+{}{}".format(a,b,c))
		#putting generated expressions in a list and then randomly choosing one of them
		l =[p,q,r,s]
		u = random.choice(l)
        
	#this loop makes random equations for a 1-digit answer
	v = '10'
	while splice(v) > 9 or splice(v) < 0 or type(splice(v)) == float:
		a = random.randint(1,9)
		b = random.randint(1,9)
		c = random.randint(1,9)
		d = random.randint(1,9)
		e = random.randint(1,9)
		operators = ['+', '-','*','/']
		#filling 6 places with random integers(1-digit) and operators
		p1 = ("{}{}{}{}{}{}".format(a,d, random.choice(operators),b,random.choice(operators),c))
		p2 = ("{}{}{}{}{}{}".format(a, random.choice(operators),b,d,random.choice(operators),c))
		p3 = ("{}{}{}{}{}{}".format(a, random.choice(operators),b,random.choice(operators),c,d))
		p4 = ("{}{}{}/{}{}".format(a,b,c,d,e))
		p5 = ("{}{}{}-{}{}".format(a,b,c,e,d))
		#again putting the generated expressions in a list and choosing one of them
		l = [p1,p2,p3,p4,p5]
		v = random.choice(l)
	
	#then we put the 3 chosen expressions in another list and choose one of them
	x = [t,u,v]
	y = random.choice(x)
	return y

#making our answer eqaution by taking the generated expression and it's result and putting them together
z = eqgen()
s = ("{}={}".format(z,splice(z)))

